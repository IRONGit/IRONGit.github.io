<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="good good study day day up">
<meta property="og:type" content="website">
<meta property="og:title" content="Chenwei Zhao's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Chenwei Zhao's blog">
<meta property="og:description" content="good good study day day up">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Chenwei Zhao's blog">
<meta name="twitter:description" content="good good study day day up">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Chenwei Zhao's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Chenwei Zhao's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">good good study day day up</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/JavaScript高级程序设计第十一章笔记/" itemprop="url">
                  JavaScript高级程序设计第十一章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T17:08:49+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>Element Traversal API为DOM元素添加了以下5个属性</p>
<p>childElementCount</p>
<p>firstElementChild</p>
<p>lastElementChild</p>
<p>previousElementSibling</p>
<p>nextElementSibling</p>
<p>从此我们不再需要为文本节点困扰了~</p>
<pre><code>//遍历某元素的所有子元素
var i,len,child=element.firstElementChild;
while(child!=element.lastElementChild){
  processChild(child);
  child=child.nextElementChild;
}
</code></pre><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h3><h4 id="试着删除一个类名"><a href="#试着删除一个类名" class="headerlink" title="试着删除一个类名"></a>试着删除一个类名</h4><pre><code>function removeClassName(node,className){
  ///\s+/匹配任意空白字符
  var classNames=node.className.split(/\s+/);
  var pos,i,len;
  for(i=0,len=classNames.length;i&lt;len;i++){
    if(classNames[i]==className){
      pos=i;
      break;
    }
  }

  classNames.splice(i,1);
  node.className=classNames.join(&quot; &quot;);
}
</code></pre><h4 id="使用DOMTokenList的实例classList"><a href="#使用DOMTokenList的实例classList" class="headerlink" title="使用DOMTokenList的实例classList"></a>使用DOMTokenList的实例classList</h4><pre><code>//迭代类名
for(var i=0,len=div.classList.length;i&lt;len;i++){
  doSomething(div.classList[i]);
}
</code></pre><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>在文档刚刚加载完成时,document.activeElement中保存的是document.body的引用</p>
<p>文档加载期间,值为null</p>
<h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>HTML5规定添加非标准的属性需要添加前缀data-</p>
<p>添加自定义属性后,可以通过dataset属性访问自定义属性的值</p>
<pre><code>var node=document.getElementById(&quot;node&quot;);
node.setAttribute(&quot;data-myname&quot;,&quot;zhangsan&quot;);
node.setAttribute(&quot;data-myage&quot;,20);

alert(node.dataset.myname);//zhangsan
alert(node.dataset.myage);//20
</code></pre><h3 id="innerHTML和outerHTML"><a href="#innerHTML和outerHTML" class="headerlink" title="innerHTML和outerHTML"></a>innerHTML和outerHTML</h3><p>使用innerHTML直接插入HTML字符串很简单,但是要注意的一点是,大多数浏览器中,通过innerHTML插入<script></p>
<p>标签并不会执行其中的脚本</p>
<p>只有IE8以及之前的版本可以执行</p>
<p>但是有两个条件,一个是<script>元素必须指定defer属性,二是<script>标签必须在”有作用域的元素”之后</p>
<p>有三种方法可以正常执行</p>
<p>一般下面这种方法是首选方法</p>
<p>div.innerHTML=”<input type=\"hidden\"><script defer>alert(\”hi\”);</script>“;</p>
<h4 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h4><pre><code>//年少无知的我就这么写过......
for(var i=0,len=values.length;i&lt;len;i++){
  ul.innerHTML+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
}

//这种方法....完美啊
var itemsHtml=&quot;&quot;;
for(var i=0,len=values.length;i&lt;len;i++){
  items+=&quot;&lt;li&gt;&quot;+values[i]+&quot;&lt;/li&gt;&quot;;
}
ul.innerHTML=itemsHtml;
</code></pre><h2 id="专有扩展"><a href="#专有扩展" class="headerlink" title="专有扩展"></a>专有扩展</h2><h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><p>children是HTMLCollection的实例,只包含元素中还是元素的子节点</p>
<p>IE8之前的children也会包含注释节点</p>
<h3 id="innerText和outerText"><a href="#innerText和outerText" class="headerlink" title="innerText和outerText"></a>innerText和outerText</h3><p>假如有下面这样一种情况</p>
<pre><code>&lt;div&gt;
  &lt;p&gt;Hello World&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;


var div=document.getElementsByTagName(&quot;div&quot;)[0];
//巧妙地删除了div中的html标签
div.innerText=div.innerText;


//确保跨浏览器兼容的方法
function getInnerText(element){
  return (typeof element.textContent==&quot;string&quot;)?element.textContent:element.innerText;
}

function setInnerText(element,text){
  if(typeof element.textContent==&quot;string&quot;){
    element.textContent=text;
  }else{
    element.innerText=text;
  }
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/13/JavaScript高级程序设计第八章笔记/" itemprop="url">
                  JavaScript高级程序设计第八章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-13T17:00:07+08:00" content="2016-05-13">
              2016-05-13
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="BOM中的对象"><a href="#BOM中的对象" class="headerlink" title="BOM中的对象"></a>BOM中的对象</h1><h2 id="核心对象-window对象"><a href="#核心对象-window对象" class="headerlink" title="核心对象:window对象"></a>核心对象:window对象</h2><p>  全局作用域</p>
<p>  在全局作用域中声明的变量函数都会变成window对象的属性和方法</p>
<p>  但是只有直接在window对象上定义的属性可以通过delete删除</p>
<p>  因为使用var定义的window属性的[[Configurable]]属性的值是false</p>
<p>  [[Configurable]]表示能否通过delete删除属性,直接在对象上定义的属性默认值为true</p>
<pre><code>var age=29;
window.color=&quot;red&quot;;
delete window.age;
delete window.color;

function t(){
  var a=10;
  return function(){
    return a;
  }
  delete a;
}
</code></pre><p>可以通过window知道某个可能未声明的变量是否存在</p>
<pre><code>var newValue=oldValue;//报错
var newValue=window.oldValue;//undefined
</code></pre><p>窗口位置</p>
<pre><code>var leftPos=(typeof window.screenLeft == &quot;number&quot;)?window.screenLeft:window.screenX;//窗口相对于屏幕左边的位置
var rightPos=(typeof window.screenRight==&quot;number&quot;)?window.screenRight:window.screenY;//窗口相对于屏幕右边的位置
</code></pre><p>窗口大小</p>
<p>innerWidth,innerHeight,outerWidth,outerHeight</p>
<pre><code>alert(window.innerWidth===window.outerWidth);//true
</code></pre><p>导航和打开窗口</p>
<pre><code>var bdWin=window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;);
if(bdWin==null){
  alert(&quot;blocked!&quot;);
}
</code></pre><p>超时调用</p>
<pre><code>var timeoutId=setTimeout(function(){
  alert(&quot;hello world&quot;);
},1000);
clearTimeout(timeoutId);
</code></pre><p>间歇调用</p>
<pre><code>var num1=0;
var max=10;
var intervalId=null;

function incrementNumber(){
  num1++;
  console.log(num1);
  if(num1==max){
    clearInterval(intervalId);
    alert(&quot;Done&quot;);
  }
}
intervalId=setInterval(incrementNumber,500);
</code></pre><p>最好用超时调用模拟间歇调用,因为使用间歇调用很可能会有后一个间歇调用在前一个间歇调用结束之前启动的情况</p>
<pre><code>var num=0;
var max=10;

function incrementNumber(){
  console.log(num);
  num++;
  if(num&lt;max){
    setTimeout(incrementNumber,500);
  }else{
    alert(&quot;Done&quot;);
  }
}
setTimeout(incrementNumber,500);
</code></pre><p>系统对话框</p>
<pre><code>/*confirm*/
if(confirm(&quot;Are you sure?&quot;)){
  window.location.href=&quot;http://www.baidu.com&quot;;
}else{
  window.location.href=&quot;http://www.youku.com&quot;;
}

/*
  如果用户单击了OK,prompt返回文本输入域的值否则返回null
*/
var result=prompt(&quot;What&apos;s your name?&quot;,&quot;Michael&quot;);
if(result!==null){
  alert(&quot;Welcome, &quot;+result);
}
</code></pre><h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>document.location和window.location引用的是同一个对象</p>
<h3 id="封装一个解析查询字符串的函数吧"><a href="#封装一个解析查询字符串的函数吧" class="headerlink" title="封装一个解析查询字符串的函数吧"></a>封装一个解析查询字符串的函数吧</h3><pre><code>//?name=&quot;zhangsan&quot;&amp;age=20
//自己写的
function getQueryStringArgs(){
  var qs=window.location.search.length&gt;0?location.search.substring(1):&quot;&quot;;
  console.log(qs.length);
  if(qs.length&gt;0){
    var sps=qs.split(&quot;&amp;&quot;);
    var items=null,name=null,value=null,i=0;
    var args={};
    for(i=0;i&lt;sps.length;i++){
      items=sps[i].split(&quot;=&quot;);
      name=decodeURIComponent(items[0]);
      value=decodeURIComponent(items[1]);
      if(name.length&gt;0){
        args[name]=value;
      }
    }
  }
  return args;
}


//书上的
function getQueryStringArgs(){
  var qs=location.search.length&gt;0?location.search.substring(1):&quot;&quot;;

  args={};

  items=qs.length?qs.split(&quot;&amp;&quot;):[];

  item=null,name=null,value=null;

  i=0;
  len=items.length;
  for(i=0;i&lt;len;i++){
    item=items[i].split(&quot;=&quot;);
    name=decodeURIComponent(item[0]);
    value=decodeURIComponent(item[1]);
    if(name.length&gt;0){
      args[name]=value;
    }
  }
  return args;
}
function getAll(){
  for(var key in args){
    console.log(key+&quot; &quot;+args[key]);
  }
}
</code></pre><h3 id="改变浏览器的位置"><a href="#改变浏览器的位置" class="headerlink" title="改变浏览器的位置"></a>改变浏览器的位置</h3><p>location.assign(“<a href="http://www.baidu.com" target="_blank" rel="external">http://www.baidu.com</a>“);</p>
<p>在使用window.location=”<a href="http://www.baidu.com&quot;和location.href=&quot;http://www.baidu.com&quot;时" target="_blank" rel="external">http://www.baidu.com&quot;和location.href=&quot;http://www.baidu.com&quot;时</a>,</p>
<p>会调用location.assign()方法</p>
<p>使用location.replace()方法可以改变浏览器位置并不产生新的浏览记录,但是无法点击后退按钮</p>
<p>使用location.reload()会重新加载(可能从缓存中加载)</p>
<p>location.reload(true);从服务器中加载</p>
<h2 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h2><h3 id="检测插件"><a href="#检测插件" class="headerlink" title="检测插件"></a>检测插件</h3><pre><code>//只能在非IE中使用
function checkPlugins(){
  var len=navigator.plugins.length;
  var plugins=navigator.plugins;
  for(var i=0;i&lt;len;i++){
    console.log(plugins[i]);
  }
}
</code></pre><h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><pre><code>function listHistory(){
  var history=window.history;
  for(var key in history){
    console.log(key+&quot; &quot;+history[key]);
  }
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/12/JavaScript高级程序设计第七章笔记/" itemprop="url">
                  JavaScript高级程序设计第七章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-12T18:12:00+08:00" content="2016-05-12">
              2016-05-12
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="定义函数的两种方式"><a href="#定义函数的两种方式" class="headerlink" title="定义函数的两种方式"></a>定义函数的两种方式</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><pre><code>function functionName(arg0,arg1,arg2){

}
</code></pre><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>  var functionName=function(arg0,arg1,arg2){</p>
<p>  }</p>
<p>函数有一个非标准的name属性,可以通过functionName.name访问到函数指定的名字</p>
<h2 id="两种方式的区别"><a href="#两种方式的区别" class="headerlink" title="两种方式的区别"></a>两种方式的区别</h2><p>在执行代码之前,会先读取函数声明,因此,函数调用可以放在函数声明之前</p>
<p>但是使用函数表达式就不行了,先调用后声明会导致出错</p>
<pre><code>//返回一个匿名函数
function createComparisonFunction(propertyName){
  return function(obj1,obj2){
    var value1=obj1[propertyName];
    var value2=obj2[propertyName];
    if(value1&lt;value2){
      return -1;
    }else if(value1&gt;value2){
      return 1;
    }else{
      return 0;
    }
  }
}

function Person(name,age){
  this.name=name;
  this.age=age;
}
Person.prototype={
  sayName:function(){
    alert(this.name);
  },
  sayAge:function(){
    alert(this.age);
  }
};
</code></pre><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>arguments.callee是一个指向正在执行函数的指针</p>
<pre><code>//应该这样递归
function factorial(num){
  if(num&lt;=1){
    return 1;
  }else{
    return num*arguments.callee(num-1);
  }
}
</code></pre><p>在严格模式下,不能访问arguments.callee,但是可以通过命名函数表达式实现相同的效果</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创</p>
</blockquote>
<p>建另一个函数</p>
<h3 id="先来说说当一个函数被创建时会发生什么"><a href="#先来说说当一个函数被创建时会发生什么" class="headerlink" title="先来说说当一个函数被创建时会发生什么"></a>先来说说当一个函数被创建时会发生什么</h3><p>首先会创建一个执行环境(execution context)</p>
<p>以及相应的作用域链，在上面的代码中，就是创建了compare的执行环境</p>
<p>然后使用arguments和其他命名参数初始化函数的活动对象(active object)</p>
<p>但在作用域链中,排在第一位的是compare的活动对象(arguments,value1,value2)</p>
<p>然后是result,compare</p>
<p>在创建compare()函数时,会创建一个预先包含全局变量对象的作用域链,并保存在[[scope]]属性中,</p>
<p>当调用compare()函数时,会为函数创建一个执行环境,并将[[scope]]属性中的作用域链复制到compare()</p>
<p>函数的执行环境中，然后将本地活动对象推入执行环境作用域链的前端</p>
<p>一般来说,函数执行完之后,局部活动对象会被销毁,内存中只保存全局作用域</p>
<pre><code>function createComparisonFunction(propertyName){
  return function(obj1,obj2){
    var value1=obj1[propertyName];
    var value2=obj2[propertyName];
    if(value1&lt;value2){
      return -1;
    }else if(value1&gt;value2){
      return 1;
    }else{
      return 0;
    }
  }
}


var compareNames=createComparisonFunction(&quot;name&quot;);

var result=compareNames({name:&quot;zhangsan&quot;},{name:&quot;lisi&quot;});

//解除对匿名函数的引用
compareNames=null;
</code></pre><p>在以上代码中,createComparisonFunction()函数返回一个匿名函数之后,匿名函数的作用域链被初始化为</p>
<p>包含createComparisonFunction()函数的活动对象和全局变量对象</p>
<p>需要注意的是,当createComparisonFunction()</p>
<p>函数返回后,它的作用域链被销毁,但是它的活动对象仍然保存在内存</p>
<p>因为匿名函数的作用域链仍然引用着它的活动对象</p>
<p>只有当匿名函数被销毁后,createComparisonFunction()函数的活动对象才会被销毁</p>
<pre><code>function createFunctions(){
  var result=new Array();
  for(var i=0;i&lt;10;i++){
    result[i]=function(){
      return i;
    }
  }
  return result;
}
</code></pre><p>在上面的代码中,createFunctions()函数返回的数组的元素全都是10</p>
<p>不过为什么全都是10呢,很重要的一点就是,result[i]=function(){}不是立即执行的</p>
<p>当createFunctions()返回时,i的值为10,并且所有的匿名函数都引用着同一个i,因为</p>
<p>闭包保存的是整个变量对象</p>
<p>如果像下面这样写,每个函数返回的值就是对应函数的下标了</p>
<pre><code>function createFunctions(){
  var result=new Array();
  for(var i=0;i&lt;10;i++){
    result[i]=function(num){
      return function(){
        return num;
      };
    }(i);
  }
  return result;
}
</code></pre><h3 id="this和arguments的问题"><a href="#this和arguments的问题" class="headerlink" title="this和arguments的问题"></a>this和arguments的问题</h3><p>this对象在运行时是基于函数的执行环境绑定的,因此在全局函数中,this就是window,当函数被某个对象调用时,this就是</p>
<p>那个对象,但是,在匿名函数中,this对象通常指向window</p>
<p>比如</p>
<pre><code>var name=&quot;window&quot;;

var object={
  name:&quot;object&quot;,
  getNameFunc:function(){
    return function(){
      return this.name;
    }
  }
};

alert(object.getNameFunc()());//window
</code></pre><p>那么怎么让闭包访问object.name呢,</p>
<p>只要可以让闭包访问到object的this对象就可以了</p>
<pre><code>var name=&quot;window&quot;;
var object={
  name:&quot;object&quot;,
  getNameFunc:function(){
    var that=this;
    return function(){
      return that.name;
    }
  }
};
alert(object.getNameFunc()());//object

//同样,如果想访问作用域中的arguments对象,必须将该对象的引用保存到一个闭包能访问到的变量中
var object={
  getNameFunc:function(name){
    var targuments=arguments;
    return function(){
      return targuments;
    }
  }
};
</code></pre><h3 id="关于this还有什么"><a href="#关于this还有什么" class="headerlink" title="关于this还有什么"></a>关于this还有什么</h3><p>书中列举了几种特殊情况</p>
<p>下面是其中一种:</p>
<pre><code>var name=&quot;The Window&quot;;

var object={
  name:&quot;object&quot;,
  getName:function(){
    return this.name;
  }
};


(object.getName=object.getName)();//非严格模式下,返回&quot;The Window&quot;
</code></pre><blockquote>
<p>因为这个赋值表达式的值是函数本身,所以this的值不能得到维持,结果就返回了”The Window”;</p>
</blockquote>
<p>说说我对这句话的理解</p>
<p>在上面的代码中,object.getName的执行环境其实是window,所以,执行了赋值语句后,object.</p>
<p>getName的this对象指向了window</p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><pre><code>function outputNumbers(count){
  (function(){
    for(var i=0;i&lt;count;i++){

    }
  })();
  alert(i);//无法访问i
}


(function(){
  var now=new Date();
  if(now.getMonth()==4&amp;&amp;now.getDate()==12){
    alert(&quot;hah&quot;);
  }
})();
</code></pre><h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>私有变量包括函数参数,局部变量,在函数内定义的其他函数</p>
<p>怎么访问这些私有变量呢?</p>
<p>可以通过在构造函数中使用闭包创建访问私有变量的公有方法</p>
<pre><code>function MyObject(){
  var privateVariable=10;
  function privateFunction(){
    return false;
  }
  this.publicMethod=function(){
    return function(){
      return privateVariable++;
    }
  }
}


(function(){
  var privateVariable=10;
  function privateFunction(){
    return false;
  };
  //函数声明只能创建局部函数
  MyObject=function(){

  };
  MyObject.prototype.publicMethod=function(){
    return privateVariable++;
  };
})();

var myObj=new MyObject();



(function(){
  //静态私有变量
  var publicAge;
  Person=function(name,age){
    this.name=name;
    publicAge=age;
  }
  Person.prototype.publicGetNameFunc=function(){
    return this.name;
  }
  Person.prototype.publicSetNameFunc=function(name){
    this.name=name;
  }
  Person.prototype.publicGetAgeFunc=function(){
    return publicAge;
  }
  Person.prototype.publicSetAgeFunc=function(age){
    publicAge=age;
  }
})();
var person1=new Person(&quot;zhangsan&quot;);
var person2=new Person(&quot;lisi&quot;,20);
</code></pre><h1 id="未完待续……"><a href="#未完待续……" class="headerlink" title="未完待续……"></a>未完待续……</h1>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/06/JavaScript高级程序设计第六章笔记/" itemprop="url">
                  JavaScript高级程序设计第六章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-06T16:53:18+08:00" content="2016-05-06">
              2016-05-06
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="怎么创建一个对象"><a href="#怎么创建一个对象" class="headerlink" title="怎么创建一个对象"></a>怎么创建一个对象</h1><h2 id="使用Object构造函数"><a href="#使用Object构造函数" class="headerlink" title="使用Object构造函数"></a>使用Object构造函数</h2><pre><code>var person=new Object();
person.name=&quot;zhangsan&quot;;
person.age=20;
person.sayName=function(){
  alert(this.name);
}
</code></pre><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><pre><code>var person={
  name:&quot;zhangsan&quot;,
  age:20,

  sayName:function(){
    alert(this.name);
  }
};
</code></pre><h1 id="ES中的两种属性"><a href="#ES中的两种属性" class="headerlink" title="ES中的两种属性"></a>ES中的两种属性</h1><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><p>有四种数据属性用于描述属性的特征</p>
<p>[[Configurable]]:表示能否通过delete操作符删除,或者能否修改为访问器属性</p>
<p>[[Enumerable]]:表示属性能否被枚举,即能否通过for-in循环返回属性</p>
<p>[[Writable]]:表示能否修改属性的值</p>
<p>[[Value]]: 包含这个属性的属性值,读取这个数据时,从这个位置读,写入属性值时,</p>
<p>将新值保存在这个位置</p>
<p>如果直接在对象中定义属性,除了[[Value]]特性都被设置为true</p>
<p>可以通过ES5的Object.defineProperty()方法修改属性默认的特性</p>
<p>调用Object.defineProperty()方法时,如果不指定,那么configurable,enumerable,</p>
<p>writable特性的默认值都是false</p>
<pre><code>var person={};
Object.defineProperty(person,&quot;name&quot;,{
  writable:false,
  value:&quot;zhangsan&quot;
});
alert(person.name);//zhangsan
person.name=&quot;lisi&quot;;
//在严格模式下,会抛出错误
alert(person.name);//还是zhangsan
</code></pre><p>修改了对象属性的Configurable属性之后,再修改writable之外的特性都会导致错误</p>
<pre><code>var person={};
Object.defineProperty(person,&quot;name&quot;,{
  configurable:false,
  value:&quot;zhangsan&quot;
});
</code></pre><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><p>  [[Configurable]]:表示能否通过delete操作符删除,默认为true</p>
<p>  [[Enumerable]]:能否通过for-in循环返回属性,默认为true</p>
<p>  [[Get]]:读取属性时调用,默认为undefined</p>
<p>  [[Set]]:写入属性时调用,默认为undefined</p>
<p>  同样,必须使用Object.defineProperty()方法定义以上特性</p>
<pre><code>var book={
  _year:2004,
  edition:1
};

Object.defineProperty(book,&quot;year&quot;,{
  get:function(){
    return this._year;
  },
  set:function(newValue){
    if(newValue&gt;2004){
      this._year=newValue;
      this.edition+=newValue-2004;
    }
  }
});


book.year=2005;
alert(book.edition);
</code></pre><p>  最好同时指定getter和setter</p>
<p>  否则在非严格模式下,只制定getter函数会导致无法写入属性,只制定setter会</p>
<p>  导致属性不能读</p>
<p>  在严格模式下,会抛出错误</p>
<h2 id="更方便的定义方法"><a href="#更方便的定义方法" class="headerlink" title="更方便的定义方法"></a>更方便的定义方法</h2><pre><code>var book={_year:2004,edition:1};

Object.defineProperties(book,{
  //定义数据属性
  _year:{
    value:2004
  },
  edition:{
    value:1
  },
  //定义访问器属性
  year:{
    get:function(){
      return this.y_ear;
    },
    set:function(){
      if(newValue&gt;2004){
        this._year=newValue;
        this.edition+=newValue-2004;
      }
    }
  }
});
</code></pre><h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><pre><code>var descriptor=Object.getOwnPropertyDescriptor(book,&quot;_year&quot;);
console.log(descriptor);

var descriptor=Object.getOwnPropertyDescriptor(book,&quot;year&quot;);
console.log(descriptor);
</code></pre><h1 id="还能怎么创建对象"><a href="#还能怎么创建对象" class="headerlink" title="还能怎么创建对象"></a>还能怎么创建对象</h1><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><pre><code>function createPerson(name,age,job){
  var o=new Object();
  o.name=name;
  o.age=age;
  o.job=job;
  o.sayName=function(){
    alert(this.name);
  }
  return o;
}
</code></pre><p>工厂模式的优点在于不用像之前那样写很多重复的代码来创建相似的对象</p>
<p>但是缺点在于无法知道生成对象的类型是什么</p>
<pre><code>var person1=createPerson(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;);
alert(person1 instanceof Object);//true
</code></pre><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><pre><code>function Person(name,age,job){
  this.name=name;
  this.age=age;
  this.job=job;
  this.sayName=function(){
    alert(this.name);
  }
}

var person1=new Person(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;);

person1有一个constructor属性,指向Person
</code></pre><p>构造函数模式胜过工厂模式的地方就是可以将通过构造函数创建的对象标识为一种</p>
<p>特定的类型</p>
<pre><code>alert(person1.constructor==Person);//true
alert(person1 instanceof Person);//true
</code></pre><p>像上面那样定义构造函数会导致每个Person实例中都有一个不同的sayName方法,</p>
<p>所以,可以把函数定义在构造函数外面</p>
<pre><code>function Person(name,age,job){
  this.name=name;
  this.age=age;
  this.job=job;
  this.sayName=sayName;
}
function sayName(){
  alert(this.name);
}
var person1=new Person(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;);
var person2=new Person(&quot;lisi&quot;,20,&quot;Software Engineer&quot;);
person1.sayName==person2.sayName;///true
</code></pre><p>不过,如果Person中有很多函数,就需要在全局作用域中定义很多函数,破坏了封装性</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>我们创建的每个函数都有一个prototype属性,prototype指向一个对象,这个对象就是</p>
<p>我们调用构造函数创建的对象的原型对象,原型对象的所有属性和方法都是被所有对象实例</p>
<p>共享的</p>
<h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><p>  说明:</p>
<p>  1.Person是构造函数</p>
<p>  2.person1是通过Person构造函数定义的对象</p>
<p>  3.Person.prototype是Person这个函数的prototype属性指向的原型对象</p>
<p>  谁指向谁:</p>
<p>  1.Person的prototype属性指向Person.prorotype</p>
<p>  2.Person.prototype的constructor(构造函数)属性指向Person</p>
<p>  3.person1(Person的实例)的[[Prototype]]属性指向Person.prototype</p>
<p>  所以,下面代码结果为true</p>
<p>  有空上图</p>
<pre><code>function Person(name,age,job){
  this.name=name;
  this.age=age;
  this.job=job;
}
Person.prototype.sayName=function(){
  alert(this.name);
}

var person1=new Person(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;);

alert(Person.prototype.isPrototypeOf(person1));//true
</code></pre><p>ES5中增加了Object.getPrototypeOf()方法,可以通过这个方法访问实例的</p>
<p>[[Prototype]]的值</p>
<pre><code>alert(Object.getPrototypeOf(person1)==Person.prototype);//true
</code></pre><p>重写实例中的属性不会影响原型中的同名属性,只会屏蔽原型对象中的同名属性,</p>
<p>当使用delete删除实例属性时,可以重新访问原型对象中的属性</p>
<p>通过使用hasOwnProperty()方法可以知道某个属性是实例的属性还是</p>
<p>原型对象的属性</p>
<p>无论属性是在原型还是在实例中,in操作符都会返回true</p>
<h3 id="封装个函数帮你确定原型中的属性"><a href="#封装个函数帮你确定原型中的属性" class="headerlink" title="封装个函数帮你确定原型中的属性"></a>封装个函数帮你确定原型中的属性</h3><pre><code>function hasPrototypeProperty(object,name){
  return !Object.hasOwnProperty(name)&amp;&amp;(name in object);
}
</code></pre><p>如果原型对象中的某个属性是不可枚举的([[Enumerable]]的值为false),</p>
<p>但是在实例对象中重新定义了这个属性,那么可以通过for-in访问</p>
<p>因为规定所有开发人员定义的属性都是可枚举的</p>
<pre><code>var keys=Object.keys(Person.prototype);
</code></pre><p>Object.getOwnPropertyNames()方法返回所有实例属性(无论是否可枚举)</p>
<p>区别:</p>
<p>for-in 只返回所有可枚举的属性(不管是在实例中还是在原型中)</p>
<p>Object.getOwnPropertyNames()返回所有实例属性(无论是否可枚举)</p>
<h3 id="用更简单的方法重写原型对象"><a href="#用更简单的方法重写原型对象" class="headerlink" title="用更简单的方法重写原型对象"></a>用更简单的方法重写原型对象</h3><pre><code>function Person(){
}
Person.prototype={
  name:&quot;zhangsan&quot;,
  age:20,
  job:&quot;Software Engineer&quot;,
  sayName:function(){
    alert(this.name);
  }
};
</code></pre><p>需要注意的是,这种字面量的写法相当于完全重写了Person.prototype对象</p>
<p>所以,Person.prototype.constructor不再指向Person,而是指向Object,</p>
<p>应该这么写:</p>
<pre><code>function Person(){
}
Person.prototype={
  constructor:Person,
  name:&quot;zhangsan&quot;,
  age:20,
  job:&quot;Software Engineer&quot;,
  sayName:function(){
    alert(this.name);
  }
};
</code></pre><p>但是,这么写又出现了一个问题</p>
<p>constructor属性的[[Enumerable]]默认是false的,即不可枚举的</p>
<p>这么写了之后,会导致[[Enumberable]]特性被设置为true,所以,</p>
<p>现在要用到这章开头提到的Object.defineProperty()函数了</p>
<p>注意在Person.prototype的字面量中不需要定义constructor属性了</p>
<pre><code>function Person(){
}
Person.prototype={
  name:&quot;zhangsan&quot;,
  age:20,
  job:&quot;Software Engineer&quot;,
  sayName:function(){
    alert(this.name);
  }
};

//只适用于与ES5兼容的浏览器
Object.defineProperty(Person.prototype,&quot;constructor&quot;,{
  enumerable:false,
  value:Person
});
</code></pre><p>像下面这样写时,会导致person1的[[Prototype]]仅仅指向最初的原型对象</p>
<p>因为以字面量定义原型对象时,相当于完全重写原型对象,因此,person1的</p>
<p>[[Prototype]]不是指向新定义的原型对象,而是指向最初的原型对象,</p>
<p>然而最初的原型对象中没有sayName这个属性</p>
<pre><code>function Person(){
}

var person1=new Person(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;);

Person.prototype={
  constructor:Person,
  name:&quot;zhangsan&quot;,
  age:20,
  job:&quot;Software Engineer&quot;,
  sayName:function(){
    alert(this.name);
  }
};

alert(person1.sayName());//报错
</code></pre><h3 id="原生对象的原型"><a href="#原生对象的原型" class="headerlink" title="原生对象的原型"></a>原生对象的原型</h3><p>原生对象的很多方法也是定义在原生对象的原型上的</p>
<p>通过原生对象的原型,可以为原生对象添加自定义的方法</p>
<p>不过不推荐修改原生对象的原型</p>
<pre><code>String.prototype.startsWith=function(text){
  return this.toLowerCase().indexOf(text.toLowerCase())==0;
}

var msg=&quot;Hello world!&quot;;
alert(msg.startsWith(&quot;Hello&quot;));//true
</code></pre><h2 id="组合构造函数模式和原型模式"><a href="#组合构造函数模式和原型模式" class="headerlink" title="组合构造函数模式和原型模式"></a>组合构造函数模式和原型模式</h2><p>构造函数模式用于定义实例属性,原型模式用于定义方法和共享的属性</p>
<pre><code>function Person(name,age,job,friends){
  this.name=name;
  this.age=age;
  this.job=job;
  this.friends=[friends];
}
Person.prototype={
  constructor:Person,
  sayName:function(){
    alert(this.name);
  },
  sayFriends:function(){
    alert(this.friends);
  }
};

var person1=new Person(&quot;zhangsan&quot;,20,&quot;Software Engineer&quot;,[&quot;lisi&quot;,&quot;wangwu&quot;]);

var person2=new Person(&quot;lisi&quot;,20,&quot;Software Engineer&quot;,[&quot;zhangsan&quot;,&quot;wangwu&quot;]);
alert(person1.sayName());
</code></pre><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><p>动态原型模式就是在构造函数中判断是否已经完成了原型的初始化</p>
<p>如果原型的未完成初始化,则初始化原型</p>
<pre><code>function Person(name,age,job,friends){
  this.name=name;
  this.age=age;
  this.job=job;
  this.friends=friends;
  //判断
  if(typeof this.sayName != &apos;function&apos; ){
    Person.prototype.sayName=function(){
      alert(this.name);
    }
    Person.prototype.sayFriends=function(){
      alert(this.friends);
    }
  }
}

var person1=new Person(&quot;zhangsan&quot;,20,&quot;SoftWare Engineer&quot;,[&quot;lisi&quot;,&quot;wangwu&quot;]);
</code></pre><h1 id="关于继承"><a href="#关于继承" class="headerlink" title="关于继承"></a>关于继承</h1><pre><code>function SuperType(){
  this.property=true;
}

SuperType.prototype.getSuperValue=function(){
  return this.property;
}

function SubType(){
  this.subproperty=false;
}
SubType.prototype=new SuperType();

SubType.prototype.getSubValue=function(){
  return this.subproperty;
}

var instance=new SubType();
alert(instance.getSuperValue());
</code></pre><p>刚开始让我困惑的是</p>
<p>书上164页上面第一段提到了instance.constructor指向SuperType</p>
<p>这一点让我想了挺长时间</p>
<p>因为我认为instance是SubType的一个实例,默认不会有constructor属性</p>
<p>只有构造函数被定义时,构造函数的原型对象才会有constructor属性</p>
<p>虽然当时我也看到了下面的注解,但是仍然有些困惑</p>
<p>最后,我得出了一个比较确定的结论,instance的constructor属性是顺着原型链</p>
<p>向上搜索得到的,instance的constructor属性也就是SuperType.prototype的</p>
<p>constructor属性,这一点通过Object.hasOwnProperty()方法也得到了验证</p>
<p>(在我把笔记转为Markdown格式的时候,发现在前面构造函数模式时,提到了对象实例拥有<br>constructor属性)</p>
<p>  alert(instance.hasOwnProperty(“constructor”));//false<br>  alert(SuperType.prototype.hasOwnProperty(“constructor”));//true</p>
<h2 id="原型链也不是完美的"><a href="#原型链也不是完美的" class="headerlink" title="原型链也不是完美的"></a>原型链也不是完美的</h2><pre><code>function SuperType(colors){
  this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
  this.name=&quot;zhangsan&quot;;
}
function SubType(){
}
SubType.prototype=new SuperType();
var instance1=new SubType();
var instance2=new SubType();
instance1.colors.push(&quot;black&quot;);
alert(instance1.name);//zhangsan
instance1.name=&quot;lisi&quot;;//lisi
alert(instance1.name);//lisi
alert(instance2.name);//zhangsan
alert(instance1.colors);//red,blue,green,black
alert(instance2.colors);//red,blue,green,black
</code></pre><p>这段代码有什么问题呢?</p>
<p>本来,在之前,我们通过使用构造函数和原型模式组合的方式,实现了一种比较好的</p>
<p>创建对象的方法(构造函数里定义实例属性,原型模式定义方法和公共属性)</p>
<p>但是,在这段代码中,我们定义的实例属性(引用类型)却被所有继承SuperType的SubType的实例</p>
<p>共有了</p>
<p>这不是我们想要的结果啊</p>
<p>所以,</p>
<blockquote>
<p>实践中很少会单独使用原型链</p>
</blockquote>
<h2 id="constructor-stealing"><a href="#constructor-stealing" class="headerlink" title="constructor stealing"></a>constructor stealing</h2><p>偷个构造函数</p>
<pre><code>function SuperType(){
  this.colors=[&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;];
}

function SubType(){
  //通过call()/apply()方法在新创建的对象上执行构造函数
  SuperType.call(this);
}

var instance1=new SubType();
instance1.colors.push(&quot;black&quot;);
var instance2=new SubType();
alert(instance1.colors);//red,blue,green,black
alert(instance2.colors);//red,blue,green
</code></pre><p>但是这种方法又导致函数无法复用,并且在超类型的原型中定义的方法,对子类型</p>
<p>而言是不可见的,所以也很少单独使用这种方法</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>使用原型链实现对原型属性和方法的继承,使用构造函数实现对实例属性的继承</p>
<pre><code>function SuperType(name){
  this.name=name;
  this.colors=[&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];
}

SuperType.prototype.sayName=function(){
  alert(this.name);
}

function SubType(name,age){
  SuperType.call(this,name);
  this.age=age;
}

SubType.prototype=new SuperType();

SubType.prototype.constructor=SubType;

SubType.prototype.sayAge=function(){
  alert(this.age);
}

var instance1=new SubType(&quot;zhangsan&quot;,20);
//alert(instance1.sayAge());//20
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/29/JavaScript高级程序设计第三章笔记/" itemprop="url">
                  JavaScript高级程序设计第三章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-29T10:48:30+08:00" content="2016-04-29">
              2016-04-29
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>ES5中有5中基本数据类型(简单数据类型)和1种复杂数据类型</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h2><p>Number,Null,Undefined,Boolean,String</p>
<p>Number类型可以表示所有数值</p>
<p>最大值:Number.MAX_VALUE</p>
<p>最小值:Number.MIN_VALUE</p>
<p>如果超过这个数值范围,并且这个数是正数,将被自动转换成Infinity,如果是负数,将被自动转换成-Infinity</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> console.log(Number.MAX_VALUE);//1.7976931348623157e+308</span><br><span class="line">console.log(Number.MIN_VALUE);//5e-324</span><br><span class="line"> var result=Number.MAX_VALUE+Number.MAX_VALUE;</span><br><span class="line"> console.log(&quot;Number.MAX_VALUE+Number.MAX_VALUE:   &quot;+result);//Infinity</span><br></pre></td></tr></table></figure>
<p>可以使用isFinite()函数确定一个数是不是有穷的</p>
<p>另外,ES6还引入了两个常量</p>
<p>Number.MIN_SAFE_INTEGER</p>
<p>Number.MAX_SAFE_INTEGER</p>
<p>分别表示-2^53+1和2^53-1</p>
<p>JavaScript内置的最大的整数是2的53次方</p>
<p>所以这两个常量代表的是安全的最大整数和安全的最小整数</p>
<pre><code>console.log(Number.MIN_SAFE_INTEGER);
console.log(Number.MAX_SAFE_INTEGER);
</code></pre><h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型:"></a>复杂数据类型:</h2><p>Object</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>ES中没有函数签名的概念,因为函数参数是以一个包含零个或多个值的数组的形式传递的</p>
<p>在函数体内可以通过arguments对象来访问参数数组</p>
<p>arguments的值永远与对应命名参数的值保持同步</p>
<pre><code>function doAdd(num1,num2){
    arguments[1]=10;//arguments[1]被赋值为10,同时num2的值变为10
    console.log(arguments[0]+num2);
}
doAdd(1,2);//11
</code></pre><p>arguments对象的长度是由传入的参数个数决定的,不是由定义函数时的命名参数个数决定的</p>
<pre><code>function doAdd(num1){
    arguments[1]=10;
    console.log(arguments[0]+arguments[1]);
}
doAdd(2);//12
</code></pre><p>即使只在参数列表里定义了一个num1,也可以通过arguments对象设置更多的参数</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>ES中不能像Java那样实现重载,如果定义了两个名字相同的函数,则该名字只属于后定义的函数</p>
<p>但是可以通过如下方式模仿方法的重载</p>
<pre><code>function doAdd(){
    if(arguments.length==1){
        console.log(&quot;只有一个参数&quot;);
    }else if(arguments.length==2){
        console.log(&quot;有两个参数&quot;);
    }else{
        console.log(&quot;不知道有多少个参数&quot;);
    }
}
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/28/JavaScript高级程序设计第五章笔记/" itemprop="url">
                  JavaScript高级程序设计第五章笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-28T21:14:05+08:00" content="2016-04-28">
              2016-04-28
            </time>
          </span>

          

          
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h1><h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>Array类型有两种创建方式</p>
<p>1.Array构造函数</p>
<p>2.数组字面量</p>
<pre><code>var colors=[&quot;red&quot;,&quot;white&quot;];
alert(colors[0]);//red
alert(colors[2]);//undefined
</code></pre><p>数组的length属性可以被修改</p>
<p>因此改变length可以移除数组末尾的元素或者添加新的元素</p>
<pre><code>//移除末尾元素
colors.length=1;
alert(colors[1]);//undefined
//添加新的元素
colors[colors.length]=&quot;green&quot;;
colors[colors.length]=&quot;black&quot;;
alert(colors[1]);
alert(colors[2]);
</code></pre><p>数组的长度有限制,如果超过上限值,会发生异常,如果创建的数初始大小与上限值接近,可<br>能会导致运行时间超长的脚本错误</p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><p>要想检测某个值是不是数组,推荐使用ES5中新增的isArray()方法,目前IE9+,FireFox 4+,Safari 5+ Opera 10.5+ Chrome中都支持这个方法</p>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>数组的toString()方法返回的是由数组中的每个值的字符串形式拼接,以逗号分隔的字符串<br>valueOf()方法返回的是数组</p>
<p>ES中的数组具有类似于栈和队列的方法</p>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>push():向数组末尾添加元素并返回长度</p>
<p>pop():移除数组末尾最后一项</p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>shift():移除数组的第一项并返回长度</p>
<p>unshift():在数组前端添加任意个项并返回新数组的长度</p>
<pre><code>var colors=new Array(&quot;white&quot;);
var count=colors.unshift(&quot;red&quot;,&quot;green&quot;);
alert(colors);//red,green,white
colors.unshift(&quot;black&quot;);//black,red,green,white
</code></pre><p>结合shift()方法和push()方法可以模拟队列</p>
<p>结合unshift()和pop()方法可以从相反的方向模拟队列</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组有两个方法可以用来重排序一个是reverse(),一个是sort(),两个方法的返回值都是排序后的数组</p>
<p>reverse()就是把数组反转</p>
<p>需要注意的是,sort()方法在执行时会调用每项的toString()方法,然后比较得到的字符串</p>
<p>所以,如下代码的结果应该是 0,1,10,15,5</p>
<pre><code>var values=[0,1,5,10,15];
values.sort();
alert(values);//0,1,10,15,5
</code></pre><p>不过,sort()函数可以接收一个比较函数作为参数,以此来决定哪个值在前哪个值在后</p>
<pre><code>function compare(value1,value2){
    if(value1&lt;value2){
        return -1;
    }else if(value1&gt;value2){
        return 1;
    }else{
        return 0;
    }
}
</code></pre><p>比较函数接收两个参数,通过返回一个数值来影响排序结果,如果第一个参数在第二个参数前,返回一个负数,如果第一个参数在第二个参数后,返回一个正数,相等则返回0</p>
<pre><code>var values=[0,1,10,5,15];
values.sort(compare);
alert(values);//0,1,5,10,15
</code></pre><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>concat():</p>
<p>首先创建一个数组的副本,然后将参数添加到副本的末尾,最后返回新数组</p>
<p>slice():</p>
<p>例:</p>
<p>slice(1)</p>
<p>返回数组位置1到数组末尾的所有项</p>
<p>slice(1,4)</p>
<p>返回数组位置1到位置3的所有项(左闭右开)</p>
<p>参数存在负数的情况:</p>
<p>在一个长度为5的数组中</p>
<p>slice(-2,-1)与slice(3,4)相同,如果结束位置小于起始位置,返回空数组</p>
<p>splice():</p>
<p>splice()函数可以在数组中实现删除,插入和替换的功能</p>
<p>返回值是一个数组,数组中包含从原始数组中删除的项(删除项数为0则返回空数组)</p>
<p>splice()的第一个参数表示起始位置,第二个参数表示要删除的项数</p>
<p>比如splice(0,1);表示从数组的位置0开始,删除一项</p>
<p>splice(1,0,”yellow”,”orange”)</p>
<p>表示从数组的位置1开始删除0项,并从位置1开始插入”yellow”,”orange”两项</p>
<p>splice(1,1,”red”,”purple”)</p>
<p>表示从数组的位置1开始删除一项,并从位置一开始插入”red”,”purple”两项</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>every()和some()都用于查询数组中的项是否满足某个条件</p>
<p>必须所有项都返回true,every()才返回true</p>
<p>只要有一项返回true,some()就返回true</p>
<pre><code>var numbers=[1,2,3,4,5,4,3,2,1];

var everyResult=numbers.every(function(item,index,array){
        return (item&gt;2);
});

alert(everyResult);//false


var someResult=numbers.some(function(item,index,array){
        return (item&gt;2);
});

alert(someResult);//true
</code></pre><p>filter()用于查询符合条件的所有项</p>
<pre><code>var numbers=[1,2,3,4,5,4,3,2,1,4];

var filterResult=numbers.filter(function(item,index,array){
        return (item&gt;2);
});

alert(filterResult);
</code></pre><p>map()用于创建一个与原数组的项一一对应的数组</p>
<pre><code>var numbers=[1,2,3,4,5,4,3,2,1,4];
var mapResult=numbers.map(function(item,index,array){
        return item*2;
});
</code></pre><p>forEach()方法没有返回值;</p>
<pre><code>var numbers=[1,2,3,4,5,4,3,2,1];
numbers.forEach(function(item,index,array){
        alert(numbers[index]);
});
</code></pre><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ES5新增了两个归并方法:</p>
<p>reduce()和reduceRight()</p>
<p>感觉在这本书上对这两个方法的描述不太清楚,但是看书还是能看懂的,后来查了一下,在MSDN上找到了一个不错的解释</p>
<blockquote>
<p>array1.reduce(callbackfn[, initialValue])</p>
<p>对数组中的所有元素调用指定的回调函数。该回调函数的返回值为累积结果，并且此返回值在下一次调用该回调函数时作为参数提供</p>
</blockquote>
<pre><code>var values=[1,2,3,4,5];
var sum=values.reduce(function(prev,cur,index,array){
        return prev+cur;
},5);

alert(sum);//20


//MSDN的示例

function Process(prev,cur){
    var nextArr;
    if(cur&lt;=10&amp;&amp;cur&gt;=1){
        nextArr=prev.concat(cur);
    }else{
        nextArr=prev;
    }
    return nextArr;
}


    var numbers = [20, 1, -5, 6, 50, 3];
    var emptyArray=new Array();
    var resultArray=numbers.reduce(Process,emptyArray);

    alert(resultArray);//1,6
</code></pre><p>prev代表前一个值,cur代表当前的值,index代表项的索引,array代表数组对象</p>
<p>需要注意的是,在第一次迭代时,prev参数是数组的第一项,cur是数组的第二项,</p>
<p>也就是说迭代是从数组的第二项开始的</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><p>有三个方法<br>        Date.parse();<br>        Date.UTC();<br>        Date.now();<br>        其中Date.now()是ES5新增的方法<br>        在不支持Date.now()方法的浏览器中,使用+操作符可以获取Date对象的时间戳</p>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><blockquote>
<p>说起来ECMAScript中什么最有意思,我想那莫过于函数了-而有意思的根源,则在于函数实际上是对象</p>
</blockquote>
<p>一个函数可以被当做参数传递给另一个函数,也可以被另一个函数当做函数的结果返回</p>
<pre><code>function callSomeFunction(someFunction,someArguments){
    return someFunction(someArguments);
}

function add10(num){
    return num+10;
}

var result1=callSomeFunction(add10,10);
alert(result1);
</code></pre><p>给对象数组排序(根据对象的属性)</p>
<pre><code>function createComparisonFunction(propertyName){
    return function comparisonFunction(obj1,obj2){
        var val1=obj1[propertyName];
        var val2=obj2[propertyName];
        if(val1&lt;val2){
            return -1;
        }else if(val1&gt;val2){
            return 1;
        }else{
            return 0;
        }
    }
}
var data=[{name:&quot;Zachary&quot;,age:28},{name:&quot;Nicholas&quot;,age:29}];
data.sort(createComparisonFunction(&quot;name&quot;));
console.log(data);
data.sort(createComparisonFunction(&quot;age&quot;));
console.log(data);
</code></pre><h3 id="函数内部的arguments对象"><a href="#函数内部的arguments对象" class="headerlink" title="函数内部的arguments对象"></a>函数内部的arguments对象</h3><p>每个函数内部都有一个arguments对象,主要功能是保存函数参数</p>
<p>但是这个对象还有一个属性callee,这个属性是一个指针,指向拥有这个arguments对象的</p>
<p>函数</p>
<pre><code>//阶乘
function factorial(num){
    if(num&lt;=1){
        return 1;
    }else{
        return num*arguments.callee(num-1);
    }
}
</code></pre><p>函数内部的this对象<br>        var color=”red”;<br>        var sayColor=function(){<br>            this.color=”blue”;<br>            alert(this.color);<br>        }<br>        sayColor();</p>
<p>caller属性保存着调用当前函数的函数的引用</p>
<p>如果在全局作用域中调用当前函数,caller的值为null</p>
<pre><code>function outer(){
    inner();
}

function inner(){
    alert(arguments.callee.caller);
}

outer();//显示outer函数的源代码

inner();//显示null

/*hidden*/
(function (n){
    if(n&lt;=1) return 1;
    return n*arguments.callee(n-1);
})(10);
</code></pre><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><p>函数也是对象,所以函数也有属性和方法,</p>
<p>每个函数都有两个属性:prototype和length</p>
<p>length表示接收的命名参数的个数</p>
<pre><code>function sayName(name){
    arguments[1]=4;
    alert(name);
}
alert(sayName.length);//1
</code></pre><p>prototype属性//链接到第六章待更新</p>
<p>每个函数也都包含两个非继承而来的方法:apply()和call()</p>
<p>两个方法的功能一样,不同点在于传入的参数不同</p>
<p>apply()方法和call()方法的第一个参数都是this,代表当前作用域</p>
<p>apply()的第二个参数可以是arguments对象,也可以是Array的实例</p>
<p>但是在使用call()时,传递的参数必须依次列举出来</p>
<pre><code>function sum(num1,num2){
    return num1+num2;
}

function callSum1(num1,num2){
    return sum.apply(this,arguments);
}


function callSum2(num1,num2){
    return sum.apply(this,[num1,num2]);
}

function callSum3(num1,num2){
    return sum.call(this,num1,num2);
}
</code></pre><p>apply()和call()方法最大的作用是扩充函数的作用域</p>
<pre><code>var color=&quot;red&quot;;
var o={color:&quot;blue&quot;};
function sayColor(){
    alert(this.color);
}
sayColor();
sayColor.call(this);//red
sayColor.call(o);//blue
sayColor.call(window);//red
</code></pre><p>这样做的最大好处就是解除了对象o和sayColor函数的耦合关系</p>
<p>不需要像之前那样写o.sayColor=sayColor了</p>
<p>ES5还有一种方法bind()</p>
<p>bind()函数接收一个对象,创建一个函数的实例,实例的this值被绑定给对象</p>
<pre><code>window.color=&quot;red&quot;;
var o={color:&quot;blue&quot;};
var obj={color:&quot;black&quot;};
function sayColor(){
    alert(this.color);
}
var objSayColor=sayColor.bind(o);
objSayColor();//blue
var objSayColor1=sayColor.bind(obj);
objSayColor1();//black
</code></pre><h2 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h2><h3 id="创建正则表达式的两种方式"><a href="#创建正则表达式的两种方式" class="headerlink" title="创建正则表达式的两种方式"></a>创建正则表达式的两种方式</h3><h4 id="1-使用字面量形式"><a href="#1-使用字面量形式" class="headerlink" title="1.使用字面量形式"></a>1.使用字面量形式</h4><pre><code>var expression= / pattern / flags;
</code></pre><p>例如:</p>
<pre><code>var pattern1=/at/g
</code></pre><p>匹配字符串中所有”at”的实例</p>
<p>每个正则表达式都可以带有一个或多个flags</p>
<p>g:表示全局(global)模式</p>
<p>i:表示不区分大小写(case-insensitive)模式</p>
<p>m:表示多行模式(multiline)模式</p>
<h4 id="2-使用RegExp构造函数"><a href="#2-使用RegExp构造函数" class="headerlink" title="2.使用RegExp构造函数"></a>2.使用RegExp构造函数</h4><pre><code>var pattern2=new RegExp(&quot;cat&quot;,g);
</code></pre><h3 id="两种方式的对比"><a href="#两种方式的对比" class="headerlink" title="两种方式的对比"></a>两种方式的对比</h3><p>在ES3中,正则表达式字面量始终会共享同一个RegExp实例,而使用构造函数创建的<br>每一个新RegExp实例都是一个新实例</p>
<p>在下面第一个循环中,只为/cat/创建了一个实例,所以在循环中再次调用test()会失败<br>,因为在第一次调用test()之后,找到了”cat”,第二次调用就会从索引为3的字符开始,<br>所以找不到</p>
<p>但是在ES5中,使用正则表达式字面量和直接调用RegExp一样,每次都创建新的RegExp实例</p>
<pre><code>var re=null,i;
for(i=0;i&lt;10;i++){
    re=/cat/g;
    console.log(re.test(&quot;catestrophe&quot;));
}

for(i=0;i&lt;10;i++){
    re=new RegExp(&quot;cat&quot;,g);
    console.log(re.test(&quot;catestrophe&quot;));
}
</code></pre><h3 id="RegExp实例属性"><a href="#RegExp实例属性" class="headerlink" title="RegExp实例属性"></a>RegExp实例属性</h3><p>RegExp的每个实例都有如下几个属性:<br>1.global</p>
<p>2.ignoreCase</p>
<p>3.lastIndex</p>
<p>4.multiline</p>
<p>5.source</p>
<p>其中lastIndex表示开始搜索下一个匹配项的字符位置</p>
<p>source返回的是正则表达式的字面量形式</p>
<h3 id="RegExp实例方法"><a href="#RegExp实例方法" class="headerlink" title="RegExp实例方法"></a>RegExp实例方法</h3><p>RegExp对象的主要方法是exec(),该方法接收一个参数,表示要匹配的字符串,返回的是一个数组,如果没有匹配项,返回null,如果有匹配项,数组存放的就是捕获组<br>返回的数组比Array实例多了两个属性,index和input,index表示匹配项在字符串中的位置,input表示传入的字符串</p>
<pre><code>var text=&quot;mom and dad and baby&quot;;
var pattern=/mom (and dad (and baby)?)?/gi;

var matches=pattern.exec(text);
console.log(matches.index);//0
console.log(matches.input);//mom and dad and baby
console.log(matches[0]);//mom and dad and baby
console.log(matches[1]);//and dad and baby
console.log(matches[2]);//and baby
</code></pre><p>对exec()方法而言,如果在模式中设置了全局标志,在同一个字符串中调用多次会在字符串中继续查找新的匹配项<br>如果不设置,则每次调用始终返回第一个匹配项的信息</p>
<pre><code>var text=&quot;cat,bat,sat,fat&quot;;
var pattern1=/.at/;
var matches=pattern1.exec(text);
console.log(matches.index);//0
console.log(matches[0]);//cat

matches=pattern1.exec(text);
console.log(matches.index);//0
console.log(matches[0]);//cat

var pattern2=/.at/g;


var matches=pattern2.exec(text);
console.log(matches.index);//0
console.log(matches[0]);//cat

matches=pattern2.exec(text);
console.log(matches.index);//4
console.log(matches[0]);//bat
</code></pre><p>另一个方法是test(),接收一个字符串参数<br>如果只想知道目标字符串和模式是否匹配而不需要知道其他细节的情况下,一般使用这个方法</p>
<p>RegExp实例继承的toLocalString()方法和toString()方法都会返回正则表达式的字面量</p>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>每当读取一个基本类型值的时候,后台会创建一个对应的基本包装类型的对象方便<br>数据操作</p>
<p>操作基本类型值的语句执行完毕之后就立即销毁这个对象</p>
<h3 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h3><pre><code>//创建Number对象可以通过Number构造函数
var numberObj=new Number(10);
</code></pre><p>valueOf()方法返回以基本类型表示的对象表示的数值</p>
<p>toString()和toLocalString()方法返回字符串形式的数值</p>
<p>可以向toString()传递一个参数表示基数</p>
<pre><code>alert(typeof numberObj.valueOf());//number
</code></pre><h4 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h4><p>toFixed()方法接收一个参数,表示小数点后的位数</p>
<pre><code>var number=10;
alert(number.toFixed(2));//10.00
</code></pre><p>如果本身的位数多余参数指定的位数,则进行舍入</p>
<pre><code>var number=10.005;
alert(number.toFixed(2));//10.01
</code></pre><p>toExponential()方法返回以指数表示法表示的数值的字符串形式</p>
<pre><code>var num=10;
alert(num.toExponential(1));//1.0e+1
</code></pre><p>toPrecision()方法会根据要处理的数值决定调用toFixed()还是toExponential()</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>String类型的每个实例都有一个length属性</p>
<p>需要注意的是,即使是双字节字符也算一个字符</p>
<pre><code>alert(&quot;哈哈&quot;.length);//2
</code></pre>
          
        
      
    </div>
    
    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="Zhao Chenwei" />
          <p class="site-author-name" itemprop="name">Zhao Chenwei</p>
          <p class="site-description motion-element" itemprop="description">good good study day day up</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhao Chenwei</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  

  

  

</body>
</html>
